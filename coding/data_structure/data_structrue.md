# 数据结构

## 一、知识结构
![图谱](./image/data_structrue.jpg)

**重点**：
* 数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie；
* 算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法；

### 算法执行效率及资源消耗
#### 1、大O复杂度表示方法

* 读数据 - 运算 - 写数据；
* 所有代码执行时间T(n)与每行代码的执行次数n成正比；

#### 2、时间复杂度分析
* 只关注**循环执行**次数最多的一段代码；

* 加法准则：总的时间复杂度等于量级最大的代码的时间复杂度;
  > O(n\*n) = O(n\*n) + O(n) + O(1)

* 乘法准则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积；

## 算法

### 链表(Linked_List)
#### 一、什么是链表？
* 1.和数组一样，链表也是一种线性表；
* 2.从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构；
* 3.链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next；

#### 二、为什么使用链表？即链表的特点
* 插入、删除数据效率高O(1)级别（只需更改指针指向即可），随机访问效率低O(n)级别（需要从链头至链尾进行遍历）。
* 和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。

#### 三、常用链表：单链表、循环链表和双向链表
* 1.单链表
  > 1）每个节点只包含一个指针，即后继指针。<br>
  > 2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。<br>
  > 3）性能特点：插入和删除节点的时间复杂度为O（1），查找的时间复杂度为O(n)。

* 2.循环链表
  > 1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。<br>
  > 2）适用于存储有循环特点的数据，比如约瑟夫问题。

* 3.双向链表
  > 1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。<br>
  > 2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。<br>
  > 3）性能特点：
    和单链表相比，存储相同的数据，需要消耗更多的存储空间。
    插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p-&gt;next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。
    对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

* 4.双向循环链表
  > 首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。

#### 四、选择数组还是链表？
* 1.插入、删除和随机访问的时间复杂度
  > 数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。
  > 链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。

* 2.数组缺点
  > 1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。
  > 2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。

* 3.链表缺点
  > 1）内存空间消耗更大，因为需要额外的空间存储指针信息。
  > 2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。

* 4.如何选择？
  > 数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。
  > 如果代码对内存的使用非常苛刻，那数组就更适合。


### 散列表(Hash Table)

> **散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。**
* 散列思想：
  > 键(key) - 散列函数(hash function) - 散列值(hash值)；
  > ![散列表](./image/散列表.jpg)
* 散列函数：
  > ![散列函数](./image/散列函数.jpg)
* 散列冲突：
  > * 开放寻址法；
  > * 链表法：
    > ![散列链表](./image/散列链表法.jpg)



### 字符串匹配算法

#### BF(Brute Force)算法
* 原理：暴力解法，模式串(m)与主串(n)循环匹配；
* 复杂度：O(n * m)
* 尽管理论上，BF 算法的时间复杂度很高，是 O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢？：
    > 第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。
    > <p>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有 bug 也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的KISS（Keep it Simple and Stupid）设计原则;
    > 

#### RK(Rabin-Karp)算法:
* 





